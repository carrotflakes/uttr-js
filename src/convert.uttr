
main statements = {
  type: "Program",
  body: concat(map(statement2body, statements)),
  sourceType: "script"
}

statement2body
{
  type: "definitionStatement",
  value
} = definition2body(value)

definition2body
{
  type: "functionDefinition",
  identifier: name,
  block
} = [function(identifier(name), functionBlock(block))],
{
  type: "constantDefinition",
  pattern,
  expression
} = variableDecls([["$", expression2expression(expression)]]) +
  pattern2body(pattern, identifier("$"))

functionBlock xs = blockStat(map([
  {
    patterns,
    guardClausesOrBody,
    whereClause
  } = backtrackable(
      [ifStat(binaryExpr("!==", dotMemberExpr(identifier("arguments"), identifier("length")), literal(length(patterns))), failedStat())] +
      variableDecls(map([i = ["$" + str(i), memberExpr(identifier("arguments"), literal(i))]], range(length(patterns)))) +
      concat(
        map([[i, p] = pattern2body(p, identifier("$" + str(i)))],
          enumerate(patterns)) +
        map(definition2body, whereClause)) +
      [
        {
          type: "body",
          value
        } = [returnStat(expression2expression(value))],
        {
          type: "guardClauses",
          value
        } = map([{guard, body} = ifStat(expression2expression(guard), returnStat(expression2expression(body)))], value)
      ](guardClausesOrBody))
], xs))

pattern2body(pattern, indicator) = [ifStat(notExpr(andExpr(conditions)), failedStat())] + variableDecls(bindings)
{
  {conditions, bindings} = patternDestructure(pattern, indicator)
}

patternDestructure(pattern, indicator) = [
  {
    type: "valueExpression",
    value
  } = {
    conditions: [callExpr(identifier("$equal"), [indicator, value2expression(value)])],
    bindings: []
  },
  {
    type: "variableExpression",
    identifier
  } = {
    conditions: [],
    bindings: [[identifier, indicator]]
  },
  {
    type: "listExpression",
    value
  } = foldl(merge, {
    conditions: [
      binaryExpr("instanceof", indicator, identifier("Array")),
      binaryExpr("===", dotMemberExpr(indicator, identifier("length")), literal(length(value)))
    ],
    bindings: []
  } :
  map([[i, v] = patternDestructure(v, memberExpr(indicator, literal(i)))], enumerate(value))),
  {
    type: "objectExpression",
    members
  } = foldl(merge, {
    conditions: [andExpr([
      binaryExpr("instanceof", indicator, identifier("Object")),
      notExpr(binaryExpr("instanceof", indicator, identifier("Array")))
    ])],
    bindings: []
  } :
  map([
    {type: "propertyMember", identifier: name, value} = patternDestructure(value, memberExpr(indicator, literal(name)))
  ], members)),
  {
    type: "consExpression",
    car, cdr
  } = foldl(merge, [
    {
      conditions: [andExpr([
        binaryExpr("instanceof", indicator, identifier("Array")),
        binaryExpr(">=", dotMemberExpr(indicator, identifier("length")), literal(1))
      ])],
      bindings: []
    },
    patternDestructure(car, memberExpr(indicator, literal(0))),
    patternDestructure(cdr, callExpr(dotMemberExpr(indicator, identifier("slice")), [literal(1)]))
  ])
](pattern)
{
  merge({conditions: c1, bindings: b1}, {conditions: c2, bindings: b2}) = {conditions: c1 + c2, bindings: b1 + b2}
}
//"applyExpression" "atPattern"

value2expression
{
  type: "numberValue",
  value
} = literal(value),
{
  type: "stringValue",
  value
} = literal(value),
{
  type: "boolValue",
  value
} = literal(value),
{
  type: "nullValue"
} = literal(null)
// TODO

expression2expression
{
  type: "valueExpression",
  value
} = value2expression(value),
{
  type: "variableExpression",
  identifier: name
} = identifier(name),
{
  type: "applyExpression",
  operator,
  args
}
| typeOf(operator) == "object" = {
  type: "CallExpression",
  callee: expression2expression(operator),
  arguments: map(expression2expression, args)
}
| operator == "+" = {
  type: "CallExpression",
  callee: identifier("$plus"),
  arguments: map(expression2expression, args)
}
| operator == "==" = {
  type: "CallExpression",
  callee: identifier("$equal"),
  arguments: map(expression2expression, args)
}
| operator == "!=" = notExpr({
  type: "CallExpression",
  callee: identifier("$equal"),
  arguments: map(expression2expression, args)
})
| elem(operator, ["-", "*", "/", "%", "<", ">", "<=", ">="]) = binaryExpr(operator, expression2expression(args[0]), expression2expression(args[1]))
| elem(operator, ["&&", "||"]) = logicalExpr(operator, expression2expression(args[0]), expression2expression(args[1]))
| operator == "[]" = memberExpr(expression2expression(args[0]), expression2expression(args[1])),
{
  type: "listExpression",
  value
} = {
  type: "ArrayExpression",
  elements: map(expression2expression, value)
},
{
  type: "objectExpression",
  members
} = {
  type: "ObjectExpression",
  properties: map([
    {type: "propertyMember", identifier: name, value} = {
      type: "Property",
      key: identifier(name),
      computed: false,
      value: expression2expression(value),
      kind: "init",
      method: false,
      shorthand: false
    },
    {type: "spreadMember", value} = {
      type: "SpreadElement",
      argument: expression2expression(value)
    }
  ], members)
},
{
  type: "consExpression",
  car,
  cdr
} = callExpr(dotMemberExpr({
  type: "ArrayExpression",
  elements: [expression2expression(car)]
}, identifier("concat")), [expression2expression(cdr)]),
{
  type: "templateLiteral",
  parts
} = strConcatExpr(map([
  {
    type: "string",
    value
  } = literal(value),
  {
    type: "expression",
    value
  } = callExpr(identifier("$str"), [expression2expression(value)])
], parts)),
{
  type: "closureExpression",
  block
} = function(null, functionBlock(block))


function(id, body) = {
  type: "FunctionDeclaration",
  id,
  params: [],
  body,
  generator: false,
  expression: false,
  async: false
}

backtrackable(body) =
{
  type: "TryStatement",
  block: blockStat(body),
  handler: {
    type: "CatchClause",
    param: identifier("e"),
    body: blockStat([
        ifStat(
          binaryExpr(
            "!==",
            dotMemberExpr(identifier("e"), identifier("message")),
            literal("backtrack")),
          throwStat(identifier("e")))])
  },
  finalizer: null
}

guardedBlock
  ([], [], expression)               = blockStat([returnStatement(expression)]),
  ([], bindings, expression)         = blockStat([variableDecl(bindings), returnStat(expression)]),
  (conditions, bindings, expression) = ifStat(andExpr(conditions), guardedBlock([], bindings, expression))

andExpr
  [] = literal(true),
  arguments = foldl([(l, r) = logicalExpr("&&", l, r)], arguments)

strConcatExpr
  [] = literal(""),
  arguments = foldl([(l, r) = binaryExpr("+", l, r)], arguments)

failedStat() = throwStat({
    type: "NewExpression",
    callee: identifier("Error"),
    arguments: [literal("backtrack")]
  })

variableDecls
  []       = [],
  bindings = [variableDecl(bindings)]

variableDecl(bindings) = {
  type: "VariableDeclaration",
  kind: "const",
  declarations: map([
    [identifier, init] = {
      type: "VariableDeclarator",
      id: {
        type: "Identifier",
        name: identifier
      },
      init
    }
  ], bindings)
}

callExpr(callee, arguments) = {
  type: "CallExpression",
  callee,
  arguments
}

memberExpr(object, property) = {
  type: "MemberExpression",
  computed: true,
  object,
  property
}

dotMemberExpr(object, property) = {
  type: "MemberExpression",
  computed: false,
  object,
  property
}

logicalExpr(operator, left, right) = {
  type: "LogicalExpression",
  operator,
  left,
  right
}

notExpr(argument) = {
  type: "UnaryExpression",
  operator: "!",
  argument,
  prefix: true
}

binaryExpr(operator, left, right) = {
  type: "BinaryExpression",
  operator,
  left,
  right
}

identifier(name) = {
  type: "Identifier",
  name
}

literal(value) = {
  type: "Literal",
  value,
  raw: json(value)
}

blockStat(body) = {
  type: "BlockStatement",
  body
}

ifStat(test, body) = {
  type: "IfStatement",
  test,
  consequent: body,
  alternate: null
}

returnStat(argument) = {
  type: "ReturnStatement",
  argument
}

throwStat(argument) = {
  type: "ThrowStatement",
  argument
}


map
  (f, x:xs) = f(x):map(f, xs),
  (_, [])   = []

foldl
  (f, r:rs)    = foldl(f, r, rs),
  (f, l, [])   = l,
  (f, l, r:rs) = foldl(f, f(l, r), rs)

filter
  (f, [])   = [],
  (f, x:xs)
    | f(x)  = x:filter(f, xs)
    | true  = filter(f, xs)

elem
  (x, [])   = false,
  (x, y:ys)
  | x == y = true
  | true = elem(x, ys)

length
  []     = 0,
  (_:xs) = 1 + length(xs)

concat xs = foldl("+", [], xs)

range
  (end) = range(0, end, 1),
  (start, end) = range(start, end, 1),
  (start, end, step)
    | start < end = start:range(start + step, end, step)
    | true        = []

zip
  ([], _) = [],
  (_, []) = [],
  (x:xs, y:ys) = [x, y]:zip(xs, ys)

enumerate xs = zip(range(length(xs)), xs)
